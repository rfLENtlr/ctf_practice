まず配布ファイルについて確認する．
```
Arch:     i386-32-little
RELRO:    Partial RELRO
Stack:    No canary found
NX:       NX enabled
PIE:      PIE enabled
```
checksecの結果より，本バイナリは32ビットであり，canaryは無効であるが，PIEが有効であることが確認できる．加えてASLRも有効になっています．

また，ソースコードをみたり，バイナリを実行すると以下の点に気づく．
- initのアドレスがリークされている
- read関数において，bufのサイズより1バイト分だけ多く読み込んでいる
- win関数に飛ばせばシェルを取れる

1バイトのオーバーフローしただけでは，リターンアドレスを書き換えられないどころか，ebpの書き換えすらできない．しかし，問題文からもわかるように，ここが問題のポイントであり，何ができるかを考える．

まずはオーバーフローしている1バイトはどこのアドレスになるのかを調べてみる．
そこで，逆アセンブリをしてmain関数の先頭をみて，bufの含まれるスタックの様子を確認する．
```
0000122e <main>:
    122e:	8d 4c 24 04          	lea    0x4(%esp),%ecx
    1232:	83 e4 f0             	and    $0xfffffff0,%esp
    1235:	ff 71 fc             	pushl  -0x4(%ecx)
    1238:	55                   	push   %ebp
    1239:	89 e5                	mov    %esp,%ebp
    123b:	53                   	push   %ebx
    123c:	51                   	push   %ecx
    123d:	83 ec 10             	sub    $0x10,%esp
    1240:	e8 7b fe ff ff       	call   10c0 <__x86.get_pc_thunk.bx>
```
上は，main関数の先頭のアセンブリである．
普通ならebpをスタックに詰んだり，espを使用する領域分だけ引けば十分のはずだが，ebxやecxもスタックに積んでいる．

一方，main関数の末尾にも注目してみる．
```
128b:	83 c4 10             	add    $0x10,%esp
128e:	b8 00 00 00 00       	mov    $0x0,%eax
1293:	8d 65 f8             	lea    -0x8(%ebp),%esp
1296:	59                   	pop    %ecx
1297:	5b                   	pop    %ebx
1298:	5d                   	pop    %ebp
1299:	8d 61 fc             	lea    -0x4(%ecx),%esp
129c:	c3                   	ret
```
ここから，ret命令でのジャンプ先のアドレスが
```
%esp = %ecx - 0x4
```
の先示すメモリの内容である．
なんだか，%ecxが関係ありそうな雰囲気がわかります．

ここで一度スタックの中身を整理してみます．

| アドレス | 中身 |
| ---- | ----|
| ebp - 0x4 | ecx - 0x4 |
| ebp - 0x8 | ebp |
| ebp - 0xc | ebx |
| ebp - 0x10 | ecx |
| ebp - 0x20 | buf |

つまり，オーバーフローした1バイトはecxの下位ビットであることがわかります．(リトルエンディアンなので)

ということで，以上を整理すると以上のことがわかります．
- ecx-0x4の指し示す内容のアドレスにリターンする
- ecxの末尾1ビットのみを書き換えることができる．
- ecxの部分には元々esp-0x4が積まれている(アセンブリ0x122eより)
- initのアドレスリークからwinのアドレスは求めることができる

ということでbufにwinのアドレスを書いておき，ecxを書き換え該当のアドレスを参照させ，winに処理を飛ばすことで攻撃が成功しそうです．

ここで最後に1つ問題があります．それは，ASLRによりecx-0x4が指し示すべきスタックのアドレスが毎回変化してしまい，わからないということです．
ここについては，書き換える1バイトの値を固定しておき，うまくそのアドレスと合致するまで実行すれば良いでしょう．ただし，アライメントを考えて4の倍数の値で固定することに注意です．
