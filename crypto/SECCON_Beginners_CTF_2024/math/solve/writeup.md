# My solution for math

まず、配布ファイルmath.tar.gzを展開すると、以下の三つのファイルが入っている。
- [`chal.py`](../given_files/chal.py)
- [`secret.py`](../given_files/secret.py)
- [`output.txt`](../given_files/output.txt)

名前からして、`chal.py`が暗号化実行ファイル、`secret.py`が秘密のパラメータ（flagなど）、`output.txt`が実行時の出力結果（これからflagを逆算する）と推測できる。

実際に内容を確認してみる。

[`chal.py`](../given_files/chal.py)
```
from Crypto.Util.number import bytes_to_long, isPrime
from secret import (
    x,
    p,
    q,
)  # x, p, q are secret values, please derive them from the provided other values.
import gmpy2


def is_square(n: int):
    return gmpy2.isqrt(n) ** 2 == n


assert isPrime(p)
assert isPrime(q)
assert p != q

a = p - x
b = q - x
assert is_square(x) and is_square(a) and is_square(b)

n = p * q
e = 65537
flag = b"ctf4b{dummy_f14g}"
mes = bytes_to_long(flag)
c = pow(mes, e, n)

print(f"n = {n}")
print(f"e = {e}")
print(f"cipher = {c}")
print(f"ab = {a * b}")

# clews of factors
assert gmpy2.mpz(a) % 4701715889239073150754995341656203385876367121921416809690629011826585737797672332435916637751589158510308840818034029338373257253382781336806660731169 == 0
assert gmpy2.mpz(b) % 35760393478073168120554460439408418517938869000491575971977265241403459560088076621005967604705616322055977691364792995889012788657592539661 == 0
```

[`secret.py`](../given_files/secret.py)
```
import gmpy2

p = # REDUCTED
q = # REDUCTED
x = # REDUCTED
```

[`output.txt`](../given_files/output.txt)
```
n = 28347962831882769454618553954958819851319579984482333000162492691021802519375697262553440778001667619674723497501026613797636156704754646434775647096967729992306225998283999940438858680547911512073341409607381040912992735354698571576155750843940415057647013711359949649220231238608229533197681923695173787489927382994313313565230817693272800660584773413406312986658691062632592736135258179504656996785441096071602835406657489695156275069039550045300776031824520896862891410670249574658456594639092160270819842847709283108226626919671994630347532281842429619719214221191667701686004691774960081264751565207351509289
e = 65537
cipher = 21584943816198288600051522080026276522658576898162227146324366648480650054041094737059759505699399312596248050257694188819508698950101296033374314254837707681285359377639170449710749598138354002003296314889386075711196348215256173220002884223313832546315965310125945267664975574085558002704240448393617169465888856233502113237568170540619213181484011426535164453940899739376027204216298647125039764002258210835149662395757711004452903994153109016244375350290504216315365411682738445256671430020266141583924947184460559644863217919985928540548260221668729091080101310934989718796879197546243280468226856729271148474
ab = 28347962831882769454618553954958819851319579984482333000162492691021802519375697262553440778001667619674723497501026613797636156704754646434775647096967729992306225998283999940438858680547911512073341409607381040912992735354698571576155750843940415057647013711359949649102926524363237634349331663931595027679709000404758309617551370661140402128171288521363854241635064819660089300995273835099967771608069501973728126045089426572572945113066368225450235783211375678087346640641196055581645502430852650520923184043404571923469007524529184935909107202788041365082158979439820855282328056521446473319065347766237878289
```

おおむね推測通り、`chal.py`が暗号化実行ファイル、`secret.py`が秘密のパラメータ`p`、`q`、`x`（~検閲済み~）、`output.txt`が実行時の出力結果（これからflagを逆算する）のようである。

`chal.py`がどのような処理を行っているのか、上から順に眺める。

- 関数is_square(n: int)
    - `n`の平方根の2乗が`n`と一致するかどうか、すなわち`n`が平方数であるかどうかを、bool型（True, False）で返す。
- assert isPrime(p), assert isPrime(q)
    - `p`, `q`が素数であるかの判定を行っている。出力結果から、実行時に判定を通過しているので`p`, `q`は素数である。
- assert p != q
    - $math p \neq q$であるかの判定を行っている。出力結果から、実行時に判定を通過しているので`p \neq q`である。
- a = p - x, b = q - x
    - そのままの意味なので説明は省略。
- assert is_square(x) and is_square(a) and is_square(b)
    - `x`, `a`, `b`が平方数であるかどうかの判定を関数is_squareで行っている。
- n = p * q, e = 65537
    - そのままの意味なので説明は省略。
- flag = b"ctf4b{dummy_f14g}"
    - flag文字列をバイト列リテラルとして入力している。配布ファイルではダミーのflagが入力されている模様。
- mes = bytes_to_long(flag)
    - flag文字列をbytes_to_long関数で数値に変換している。
- c = pow(mes, e, n)
    - `c = mes^e mod n`を求めている、すなわちflagをRSAで暗号化している。
- print文
    - `n`, `e`, `c`, `ab = a \times b`の出力を行っている。
- assert文
    - `a`, `b` を続く値で割った時の余りが0であるかどうかの判定、すなわち`a`, `b`が続く値（以下、それぞれ`a'`, `b'`とおく）を約数に持つかどうかの判定を行っている。
    - `clews of factors`とコメントされていることから、おそらく`a'`, `b'`は`a`, `b`がそれぞれ持つ素因数の値である。
    - 実際に[factordb](http://www.factordb.com/index.php)を使うと、`a'`, `b'`が共に素数であることが分かる

以上をまとめると次のようになる。
- 既知の変数：`n`, `e`, `c`, `ab`, `a'`, `b'`
- 未知数：`p`, `q`, `x`, `a`, `b`
- 関係式：
    - `n = p \times q`
    - `ab = a \times b`
    - `a = p - x`
    - `b = q - x`
    - `x`, `a`, `b`は平方数
    - `a`は`a'`を素因数に持つ
    - `b`は`b'`を素因数に持つ
    - `m = pow(c, d, n)`（RSA暗号の復号）
    - `d = e^{-1} mod \varphi (n)`（RSA暗号における`d`の定義）
    - `\varphi (n) = (p - 1)\times(q - 1)`（RSA暗号における`\varphi (n)`の定義）

ここで、`a`と`b`は平方数なので、それぞれ`a'^2`, `b'^2`の倍数。

`ab`を`(a' b')^2`で割った値を求めて[factordbで素因数分解](http://www.factordb.com/index.php?query=1002777341573073149099549678043369)すると、`(3 · 173 · 199 · 306606827773)^2`となる。

つまり、`a`, `b`は`3`, `173`, `199`, `306606827773`の2乗をどちらか一方で要素として持つ。

ここから`a`, `b`の値の候補が求められる。

また、`x`の値について
```math
\begin{align}
ab &= (p - x) (q - x) \
&= pq - (p + q) x + x^2 \
&= n - (p + q) x + x^2 \
&= n - (a + b + 2x) x + x^2 \
&= n - (a + b) x - x^2 \
x^2 + (a + b) x + ab - n &= 0
\end{align}
```

```math
x^2 + (a + b) x + ab - n = 0
```

よって、二次方程式の解の公式を用いて`x`は以下のように求められる。
```math
x = \frac{- (a + b) + \sqrt{(a + b)^2 - 4 (ab - n)}}{2}
```

`x`が求まれば`p = a + x`, `q = b + x`より`p`, `q`が求まる。

`p`, `q`が求まると`\varphi (n) = (p - 1)\times(q - 1)`が求まる。

すると`d = e^{-1} mod \varphi (n)`が求まるので、`m = pow(c, d, n)`が求まる。

以上の流れを元にPythonでソースコードを記述し、実行する。

[`solve.py`](./solve.py)
```
from Crypto.Util.number import long_to_bytes, isPrime, inverse
import gmpy2

a2 = 4701715889239073150754995341656203385876367121921416809690629011826585737797672332435916637751589158510308840818034029338373257253382781336806660731169 ** 2
b2 = 35760393478073168120554460439408418517938869000491575971977265241403459560088076621005967604705616322055977691364792995889012788657592539661 ** 2

n = 28347962831882769454618553954958819851319579984482333000162492691021802519375697262553440778001667619674723497501026613797636156704754646434775647096967729992306225998283999940438858680547911512073341409607381040912992735354698571576155750843940415057647013711359949649220231238608229533197681923695173787489927382994313313565230817693272800660584773413406312986658691062632592736135258179504656996785441096071602835406657489695156275069039550045300776031824520896862891410670249574658456594639092160270819842847709283108226626919671994630347532281842429619719214221191667701686004691774960081264751565207351509289
e = 65537
cipher = 21584943816198288600051522080026276522658576898162227146324366648480650054041094737059759505699399312596248050257694188819508698950101296033374314254837707681285359377639170449710749598138354002003296314889386075711196348215256173220002884223313832546315965310125945267664975574085558002704240448393617169465888856233502113237568170540619213181484011426535164453940899739376027204216298647125039764002258210835149662395757711004452903994153109016244375350290504216315365411682738445256671430020266141583924947184460559644863217919985928540548260221668729091080101310934989718796879197546243280468226856729271148474
ab = 28347962831882769454618553954958819851319579984482333000162492691021802519375697262553440778001667619674723497501026613797636156704754646434775647096967729992306225998283999940438858680547911512073341409607381040912992735354698571576155750843940415057647013711359949649102926524363237634349331663931595027679709000404758309617551370661140402128171288521363854241635064819660089300995273835099967771608069501973728126045089426572572945113066368225450235783211375678087346640641196055581645502430852650520923184043404571923469007524529184935909107202788041365082158979439820855282328056521446473319065347766237878289
e = 65537

# a2b2 = (a2 * b2) ** 2
# print(ab // a2b2)
# => 4701715889239073150754995341656203385876367121921416809690629011826585737797672332435916637751589158510308840818034029338373257253382781336806660731169
#    = (3 · 173 · 199 · 306606827773)^2

list = [1, 3, 173, 199, 306606827773, 3 * 173, 3 * 199, 3 * 306606827773, 173 * 199, 173 * 306606827773, 199 * 306606827773]
k = 3 * 173 * 199 * 306606827773

for l in list:
    a = a2 * (l ** 2)
    b = b2 * ((k // l) ** 2)
    root, check = gmpy2.iroot(a ** 2 + b ** 2 - 2 * a * b + 4 * n, 2)
    if check:
        x = (- a - b + root) // 2
        p = a + x
        q = b + x
        if isPrime(p):
            if isPrime(q):
                phi = (p-1) * (q-1)
                d = inverse(e, phi)
                m = pow(cipher, d, n)
                mes = long_to_bytes(m)
                print(mes)
```

```
> python .\solve.py
b'ctf4b{c0u1d_y0u_3nj0y_7h3_m4theM4t1c5?}'
```

```ctf4b{c0u1d_y0u_3nj0y_7h3_m4theM4t1c5?}```
