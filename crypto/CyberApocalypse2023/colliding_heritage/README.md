# Colliding Heritage

## 概要
本問の題材は，Schnorr署名，MD5ハッシュ，およびこれらの脆弱性である．
本問を解くことで，署名の作成に用いられるハッシュ関数に不備があった時，どんな恐ろしいことが起きうるのかを学ぶことができる．


大まかな回答手順は以下のようになる：
  1. MD5ハッシュ値が等しくなる2種類のファイルを用意し，署名を作成．
  2. この署名を用いて，秘密鍵 $x$ を計算．
  3. 秘密鍵 $x$ を用いて，ローカルで`I am the left hand`に対する署名を作成．
  4. この署名をサーバプログラムに入力して署名の検証を行い，フラグを取得．

解法のポイントは2つある：
  1. 署名に用いるハッシュ関数の脆弱性に気づけるか．
  2. 30秒以内に，2種の署名の作成，秘密鍵 $x$ の計算，`I am the left hand`への署名の作成，署名の検証，を行えるか．


## 当日やったこと/当日の回答
この節では，回答者が当日何を考えていたかと，どう解いたかを示す．
(冗長であることをご容赦ください．)

### 当日の思考過程
大まかには以下の過程を経た：
  1. 問題文と与えられたファイルをざっと読む
  2. fastcollを知る
  3. Schnorr署名について学ぶ
  4. 署名に使われているハッシュ関数の脆弱性に気づく
  5. 秘密鍵 $x$ を計算するプログラムを書く
  6. 気合で30秒以内に入力を終わらせる

順を追って説明する．

#### 1. 問題と与えられたファイルをざっと読む
まず題名が **___Colliding___** Heritage であることから，ハッシュ関数の衝突に関する問題だろうと推測した．

ここで与えられた`server.py`を見てみると，`class MD5chnorr`という文字列が目に付いた．
この **MD5chnorr** という文字について，「MD5は良いとして，chnorrってなんだ？」と思いググった．
すると **Schnorr署名** という名前がヒットした．MD5の5はSchnorrのSの[リート](https://ja.wikipedia.org/wiki/Leet)だったようだ．

さて，肝心のflagの在り処は75行目であり，`b'I am the left hand'`に対する署名の検証が通ればflagが得られることが分かる．
だが署名作成の段階で，`b'I am the left hand'`を含む文字列への署名はブロックされるため，どうしたものか，となるわけである．


#### 2. fastcollを知る
Schnorr署名は良く分からなかったので一旦放置し，絶対に利用するであろうMD5ハッシュ値衝突のためのツールを探すことにした．
そして[fastcoll](https://www.win.tue.nl/hashclash/)を見つけた．

fastcollを使うと，同じMD5ハッシュ値を持つ2つのファイルを数秒で生成できる．
以下のように使う：
```
$ echo hogehoge > hoge.txt
$ ./fastcoll_v1.0.0.5.exe a -o 1.txt 2.txt
$ md5sum out1.txt out2.txt
9a79acb6f0a807adc8893e57fe0b463b  1.txt
9a79acb6f0a807adc8893e57fe0b463b  2.txt
```

#### 3. Schnorr署名について学ぶ
次に，Schnorr署名を知らないと回答の手がかりを得られないと思い，これを勉強した．
具体的には，[このサイト](https://blog.visvirial.com/articles/721)を集中的に読んだ．

詳細は割愛するが，Schnorrの方法で作成した署名は，以下の2つから成る．
  1. $e$ : 平文，乱数などに依る**ハッシュ値**
  2. $s$ : 乱数，秘密鍵， $e$ に依る値．

つまり署名作成者は，自分しか知らない**乱数**と**秘密鍵**の値を用いて，平文に署名をするのである．
逆に言えば，この乱数あるいは秘密鍵の値を絶対に漏らさないようにしなければならない．
さもなくば，別の人物が自分になりすまして署名を行うなどの攻撃が可能になってしまう．

#### 4. `server.py`の脆弱性を探す
以上を踏まえて，与えられた`server.py`に潜む脆弱性の調査を開始した．

まず，コードから読み取ることができる情報を列挙する．
(なお数式の可読性の観点から，コードフォントではなく数式フォントで書く．)

**`MD5chnorr`のコンストラクタ:**
| 変数 | 意味                                             | 状態                  |
|--    |--                                                |--                     |
| $p$  | $2 q + 1$ を満たす素数                            |公開                   |
| $q$  | ランダムな $128$ ビットの素数                      |**非公開**だが $p$ から求まる|
| $g$  | 常に $3$                                          |公開                   |
| $x$  | $q$ 以下の乱数．**秘密鍵** |**非公開**                 |
| $y$  | $g^x\bmod p$                                     |公開                   |

**`MD5chnorr`のメソッド`H`:**
| 変数 | 意味                                             | 状態                  |
|--    |--                                                |--                     |
| $H$  | $MD5(msg) \bmod q$ |公開|

**`MD5chnorr`のメソッド`sign`とその変数:**
| 変数 | 意味                                             | 状態                  |
|--    |--                                                |--                     |
| $k$  | $H(msg\|\|x) \bmod q$ | **非公開**だが $x$ が求まると求まる|
| $r$  | $g^k \bmod p \bmod q$ | **非公開**だが $k$ が求まると求まる|
| $e$  | $H(r\|\|msg)$ | 公開|
| $s$  | $(k - xe) \bmod q$ | 公開 |

上表から，非公開の値は $q$ , $x$ , $k$ , $r$ の4つであることが分かる．
ところが， $q$ は $p$ から求まり， $k$ は $x$ から求まり， $r$ は $k$ から求まるので，**本質的には $x$ だけが非公開情報ということになる**．

ここからもう少しソースコードを観察すると，58行目が`for _ in range(3):`となっていることに気づく．
署名・検証のステップを3回までトライできるということだ．最後の1試行は`b'I am the left hand'`に対する署名の検証に使うとして，余った2試行を $x$ を求めるために使えないだろうか．　

しばらく数式をつついていると，異なる2つの平文とその署名から $x$ を求める方法を思いつく：

2種の平文 $msg_1, msg_2$ に対応する署名をそれぞれ $(e_1, s_1), (e_2, s_2)$ とすると，以下の式が成り立つ．
$$s_1 = ((H(msg_1||x) \bmod q) - xe_1) \bmod q \ \ \ \ ①$$
$$s_2 = ((H(msg_2||x) \bmod q) - xe_2) \bmod q \ \ \ \ ②$$
ここで，仮に $MD5(msg_1) == MD5(msg_2)$ だったとすると，ハッシュ関数の特性から
$$H(msg_1||x) == H(msg_2||x)$$ と，
$$H(r||msg_1) \neq H(r||msg_2) \Leftrightarrow e_1 \neq e_2$$
そして，
$$s_1 \neq s_2$$
が成り立つ．つまり，**MD5ハッシュ値は同じなのに，MD5ハッシュ値を用いた署名は同じにならない**という事実が成り立つ．

これが意味するのは，**式①,②を方程式として $x$ について解くことができる**ということである．

#### 5. 秘密鍵 $x$ を計算するプログラムを書く
与えられた`server.py`を改造して[xを求めるプログラム](./solve.py)を書いた．

#### 6. 気合で30秒以内に入力を終わらせる
(**注：本当はpwntools等を使って30秒の制約をクラックする方法が望ましいです**)

CTF競技サーバ上にある`server.py`は，入力を30秒しか待ってくれないので，この間に2種の署名，`b'I am the left hand`に対する署名，検証を行わなければならない．
これをクリアするために以下のようにする．

fastcollで作ったMD5ハッシュ値が衝突する2種のファイル，`I am the left hand`の16進数表記をクリップボードにコピーするaliasを作る：
```
$ alias a="xxd -c 1 -p 1.txt | tr -d '\n' | clip.exe"
$ alias b="xxd -c 1 -p 2.txt | tr -d '\n' | clip.exe"
$ alias l="xxd -c 1 -p lefthand | tr -d '\n' | clip.exe"
```
これを使ってターミナル画面を4分割し，素早く値を入力すれば（40回くらいトライすると）フラグが得られる．

## より良い解答
https://chovid99.github.io/posts/cyber-apocalypse-2023-crypto/
を見てください（このwriteupはなんだったのか･･･）

